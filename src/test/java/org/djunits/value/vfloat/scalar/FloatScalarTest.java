package org.djunits.value.vfloat.scalar;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import org.djunits.quantity.Quantities;
import org.djunits.quantity.Quantity;
import org.djunits.unit.AbsoluteTemperatureUnit;
import org.djunits.unit.AngleUnit;
import org.djunits.unit.LengthUnit;
import org.djunits.unit.PositionUnit;
import org.djunits.unit.SpeedUnit;
import org.djunits.unit.TemperatureUnit;
import org.djunits.unit.Unit;
import org.djunits.unit.util.UNITS;
import org.djunits.unit.util.UnitException;
import org.djunits.value.CLASSNAMES;
import org.djunits.value.vfloat.scalar.base.FloatScalar;
import org.djunits.value.vfloat.scalar.base.FloatScalarAbs;
import org.djunits.value.vfloat.scalar.base.FloatScalarRel;
import org.junit.jupiter.api.Test;

/**
 * Test the FloatScalar class.
 * <p>
 * This file was generated by the djunits value test classes generator, 26 jun, 2015
 * <p>
 * Copyright (c) 2015-2025 Delft University of Technology, PO Box 5, 2600 AA, Delft, the Netherlands. All rights reserved. <br>
 * BSD-style license. See <a href="https://djunits.org/docs/license.html">DJUNITS License</a>.
 * </p>
 * @author <a href="https://www.tudelft.nl/averbraeck">Alexander Verbraeck</a>
 * @author <a href="https://www.tudelft.nl/staff/p.knoppers/">Peter Knoppers</a>
 */
public class FloatScalarTest
{
    /**
     * Check that the value in a FloatScalar matches the expected value.
     * @param ds the FloatScalar to match
     * @param reference the reference value
     * @param precision the maximum allowed error
     * @param u the expected type
     * @param expectAbsolute if true; ds should be Absolute; if false; ds should be Relative
     */
    private static void checkContentsAndType(final FloatScalar<?, ?> ds, final float reference, final float precision,
            final Unit<?> u, final boolean expectAbsolute)
    {
        assertTrue(null != ds, "FloatScalar should not be null");
        assertEquals(reference, ds.getInUnit(), precision, "Value should match");
        assertEquals(u, ds.getDisplayUnit(), "Unit should be " + u.toString());
        assertTrue(expectAbsolute ? ds.isAbsolute() : ds.isRelative(),
                "Should be " + (expectAbsolute ? "Absolute" : "Relative"));
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringAbsTest()
    {
        AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.KELVIN;
        float value = 38.0f;
        FloatAbsoluteTemperature ds = new FloatAbsoluteTemperature(value, tempUnit);
        String result = ds.toString(true, true);
        assertTrue(result.contains("Abs "), "toString result contains \"Abs \"");
        assertTrue(result.contains("K"), "toString result contains \"K\"");
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @Test
    public final void basicsAbsTest()
    {
        AbsoluteTemperatureUnit tempUnit = AbsoluteTemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        FloatAbsoluteTemperature temperatureDS = new FloatAbsoluteTemperature(value, tempUnit);
        checkContentsAndType(temperatureDS, value, 0.001f, tempUnit, true);
        assertEquals(311.15f, temperatureDS.getSI(), 0.05, "Value in SI is equivalent in Kelvin");
        assertEquals(100.4f, temperatureDS.getInUnit(AbsoluteTemperatureUnit.DEGREE_FAHRENHEIT), 0.1, "Value in Fahrenheit");
        float out = temperatureDS.getInUnit();
        assertEquals(value, out, 0.001, "Value should match");
        FloatAbsoluteTemperature mds = new FloatAbsoluteTemperature(value, tempUnit);
        checkContentsAndType(mds, value, 0.001f, tempUnit, true);
        mds = new FloatAbsoluteTemperature(-200f, tempUnit);
        assertEquals(73.0d, mds.getSI(), 1.0d, "-200 Celsius roughly equivalent to 73 Kelvin");
        mds = new FloatAbsoluteTemperature(temperatureDS);
        checkContentsAndType(mds, value, 0.001f, tempUnit, true);
        FloatAbsoluteTemperature temperature2DS = new FloatAbsoluteTemperature(temperatureDS);
        assertTrue(temperature2DS.equals(temperatureDS), "temperature2DS should be equal to temperatureDS");
        assertTrue(temperatureDS.isAbsolute(), "Value is Absolute");
        assertFalse(temperatureDS.isRelative(), "Value is not Relative");
        temperatureDS = new FloatAbsoluteTemperature(value, AbsoluteTemperatureUnit.KELVIN);
        checkContentsAndType(temperatureDS, value, 0.001f, AbsoluteTemperatureUnit.KELVIN, true);
        out = temperatureDS.getSI();
        assertEquals(value, out, 0.001, "Value should match");
    }

    /**
     * Test setDisplayUnit.
     */
    @Test
    public final void testSetDisplayUnit()
    {
        FloatSpeed s = new FloatSpeed(10.0f, SpeedUnit.KM_PER_HOUR);
        FloatSpeed t = s.setDisplayUnit(SpeedUnit.MILE_PER_HOUR);
        assertTrue(s == t);
        FloatSpeed u = FloatSpeed.ofSI(10.0f).setDisplayUnit(SpeedUnit.KM_PER_HOUR);
        assertEquals(SpeedUnit.KM_PER_HOUR, u.getDisplayUnit());
        assertEquals(10.0f, u.getSI());
    }


    /**
     * Test Angle constants.
     */
    @Test
    public final void testAngleConstants()
    {
        assertEquals(AngleUnit.RADIAN, FloatAngle.ZERO.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.ONE.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.PI.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.HALF_PI.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.TAU.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.NaN.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.POSITIVE_INFINITY.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.NEGATIVE_INFINITY.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.POS_MAXVALUE.getDisplayUnit());
        assertEquals(AngleUnit.RADIAN, FloatAngle.NEG_MAXVALUE.getDisplayUnit());

        assertEquals(0.0f, FloatAngle.ZERO.getSI());
        assertEquals(1.0f, FloatAngle.ONE.getSI());
        assertEquals((float) Math.PI, FloatAngle.PI.getSI(), 1E-6);
        assertEquals((float) (Math.PI / 2.0), FloatAngle.HALF_PI.getSI(), 1E-6);
        assertEquals((float) (Math.PI * 2.0), FloatAngle.TAU.getSI(), 1E-6);
        assertTrue(Float.isNaN(FloatAngle.NaN.getSI()));
        assertTrue(Float.isInfinite(FloatAngle.POSITIVE_INFINITY.getSI()));
        assertTrue(FloatAngle.POSITIVE_INFINITY.getSI() > 0);
        assertTrue(Float.isInfinite(FloatAngle.NEGATIVE_INFINITY.getSI()));
        assertTrue(FloatAngle.NEGATIVE_INFINITY.getSI() < 0);
        assertTrue(Float.isFinite(FloatAngle.POS_MAXVALUE.getSI()));
        assertTrue(FloatAngle.POS_MAXVALUE.getSI() > 0);
        assertTrue(Float.isFinite(FloatAngle.NEG_MAXVALUE.getSI()));
        assertTrue(FloatAngle.NEG_MAXVALUE.getSI() < 0);
    }

    /**
     * Test all "of" methods.
     * @throws SecurityException on error
     * @throws NoSuchMethodException on error
     * @throws InvocationTargetException on error
     * @throws IllegalArgumentException on error
     * @throws IllegalAccessException on error
     * @throws ClassNotFoundException on error
     * @throws UnitException on error
     */
    @Test
    public void testAllOf() throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException,
            InvocationTargetException, ClassNotFoundException, UnitException
    {
        // load all classes
        assertEquals("m", UNITS.METER.getId());

        float testValue = -123.456f;
        for (String type : CLASSNAMES.ALL_LIST)
        {
            String className = "org.djunits.value.vfloat.scalar.Float" + type;
            Class<?> scalarClass = Class.forName(className);
            Quantity<?> quantity = Quantities.INSTANCE.getQuantity(type + "Unit");
            for (Unit<?> unit : quantity.getUnitsById().values())
            {
                Method ofMethod = scalarClass.getDeclaredMethod("of", float.class, String.class);
                for (String unitAbbreviation : unit.getDefaultAbbreviations())
                {
                    FloatScalar<?, ?> scalar = (FloatScalar<?, ?>) ofMethod.invoke(null, testValue, unitAbbreviation);
                    assertEquals(scalar.getDisplayUnit().getId(), unit.getId(), "unit was not parsed correctly");
                    if (Float.isFinite(scalar.getInUnit()) && scalar.getInUnit() != 0.0f && scalar.getInUnit() != -0.0f
                            && (!unitAbbreviation.contains("(Y")))
                    {
                        assertEquals(testValue, scalar.getInUnit(), 0.5, "value was not parsed correctly");
                    }
                }
                try
                {
                    ofMethod.invoke(null, testValue, "abcQRS123");
                }
                catch (InvocationTargetException ite)
                {
                    assertTrue(ite.getCause().toString().startsWith("java.lang.IllegalArgumentException"),
                            "Exception is an IllegalArgumentException");
                }

                try
                {
                    ofMethod.invoke(null, testValue, "");
                }
                catch (InvocationTargetException ite)
                {
                    assertTrue(ite.getCause().toString().startsWith("java.lang.IllegalArgumentException"),
                            "Exception is an IllegalArgumentException");
                }
            }
        }
    }

    /**
     * Test the plus method of absolutes.
     * @throws ClassNotFoundException on error
     * @throws InvocationTargetException on error
     * @throws IllegalArgumentException on error
     * @throws IllegalAccessException on error
     * @throws SecurityException on error
     * @throws NoSuchMethodException on error
     * @throws InstantiationException on error
     */
    @Test
    public final void testAbsPlus() throws ClassNotFoundException, IllegalAccessException, IllegalArgumentException,
            InvocationTargetException, NoSuchMethodException, SecurityException, InstantiationException
    {
        // load all classes
        assertEquals("m", UNITS.METER.getId());
        assertEquals(CLASSNAMES.REL_WITH_ABS_LIST.size(), CLASSNAMES.ABS_LIST.size(), "type lists have same size");

        for (int typeIndex = 0; typeIndex < CLASSNAMES.REL_WITH_ABS_LIST.size(); typeIndex++)
        {
            String relativeType = CLASSNAMES.REL_WITH_ABS_LIST.get(typeIndex);
            String absoluteType = CLASSNAMES.ABS_LIST.get(typeIndex);
            // This relies on the REL_WITH_ABS_LIST and ABS_LIST to be maintained "in sync".
            Class<?> scalarClass = Class.forName("org.djunits.value.vfloat.scalar.Float" + relativeType);
            float relValue = 123.456f;
            for (Unit<?> relativeUnit : Quantities.INSTANCE.getQuantity(relativeType + "Unit").getUnitsById().values())
            {
                Constructor<?> relConstructor = scalarClass.getConstructor(float.class, relativeUnit.getClass());
                FloatScalarRel<?, ?> relScalar = (FloatScalarRel<?, ?>) relConstructor.newInstance(relValue, relativeUnit);
                float absValue = 234.567f;
                Quantity<?> quantity = Quantities.INSTANCE.getQuantity(absoluteType + "Unit");
                for (Unit<?> absoluteUnit : quantity.getUnitsById().values())
                {
                    // Create an abs
                    Method instantiateAbsMethod =
                            scalarClass.getDeclaredMethod("instantiateAbs", float.class, absoluteUnit.getClass());
                    FloatScalarAbs<?, ?, ?, ?> absScalar =
                            (FloatScalarAbs<?, ?, ?, ?>) instantiateAbsMethod.invoke(relScalar, absValue, absoluteUnit);
                    // method "plus" cannot be found with getMethod() for absScalar.getClass().
                    Method plusMethod = scalarClass.getMethod("plus", absScalar.getClass().getSuperclass());
                    FloatScalarAbs<?, ?, ?, ?> sum = (FloatScalarAbs<?, ?, ?, ?>) plusMethod.invoke(relScalar, absScalar);
                    // system.out.println("rel=" + relScalar + ", abs=" + absScalar + ", sum=" + sum);
                    assertEquals(absScalar.getSI() + relScalar.getSI(), sum.getSI(), Math.abs(sum.getSI() / 1e7),
                            "sum in SI equals sum of SI values");
                }
            }
        }
    }

    /**
     * Test the equals method.
     */
    @Test
    public final void equalsAbsTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        PositionUnit positionUnit = PositionUnit.DEFAULT;
        float value = 38.0f;
        FloatPosition ds = new FloatPosition(value, positionUnit);
        assertTrue(ds.equals(ds), "Equal to itself");
        assertFalse(ds.equals(null), "Not equal to null");
        assertFalse(ds.equals(new String("abc")), "Not equal to some other kind of object; e.g. a String");
        FloatLength dsCounterPart = new FloatLength(value, lengthUnit);
        assertFalse(ds.equals(dsCounterPart), "Not equal if one Absolute and other Relative");
        FloatAbsoluteTemperature dsWrongBaseUnit = new FloatAbsoluteTemperature(value, AbsoluteTemperatureUnit.KELVIN);
        assertEquals(ds.getSI(), dsWrongBaseUnit.getSI(), 0.0001, "The underlying SI values are the same");
        assertFalse(ds.equals(dsWrongBaseUnit), "Not equals because the standard SI unit differs");
        FloatPosition dsCompatibleUnit = new FloatPosition(38000.0f, PositionUnit.MILLIMETER);
        assertFalse(ds.getDisplayUnit().equals(dsCompatibleUnit.getDisplayUnit()), "Units are different");
        assertTrue(ds.equals(dsCompatibleUnit), "equals returns true");
        FloatPosition dsDifferentValue = new FloatPosition(123.456f, PositionUnit.MILLIMETER);
        assertFalse(ds.equals(dsDifferentValue), "Different value makes equals return false");
    }

    /**
     * Test the relational operations.
     */
    @Test
    public final void relOpAbsTest()
    {
        FloatPosition base = new FloatPosition(123, PositionUnit.KILOMETER);
        FloatPosition same = new FloatPosition(123000, PositionUnit.METER);
        FloatPosition smaller = new FloatPosition(122999, PositionUnit.METER);
        FloatPosition larger = new FloatPosition(123001, PositionUnit.METER);
        assertFalse(base.lt(same), "123km < 123000m");
        assertTrue(base.le(same), "123km <= 123000m");
        assertTrue(base.ge(same), "123km >= 123000m");
        assertFalse(base.gt(same), "NOT 123km > 123000m");
        assertTrue(base.eq(same), "123km == 123000m");
        assertFalse(base.ne(same), "NOT 123km != 123000m");
        assertTrue(base.lt(larger), "123km < 123001m");
        assertTrue(base.gt(smaller), "123km > 122999m");
        assertTrue(base.ge(same), "123km >= 123000m");
        assertFalse(base.gt(same), "NOT 123km > 123000m");
        assertFalse(base.lt(same), "NOT 123km < 123000m");
        assertTrue(base.le(same), "123km <= 123000m");
        assertTrue(base.ne(larger), "123km != 123001m");
        assertFalse(base.eq(larger), "NOT 123km == 123001m");
        assertTrue(base.ne(smaller), "123km != 122999m");
        assertFalse(base.eq(smaller), "NOT 123km == 122999m");
        assertFalse(base.ge(larger), "NOT 123km >= 123001m");
        assertFalse(base.le(smaller), "NOT 123km <= 122999m");
    }

    /**
     * Test the Math functions.
     */
    @Test
    public final void mathFunctionsTestAbsTest()
    {
        float[] seedValues = {-10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f};
        for (float seedValue : seedValues)
        {
            float input = seedValue;
            FloatLength floatLength;
            floatLength = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "ceil", floatLength.ceil(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return (float) Math.ceil(d);
                }
            });
            floatLength = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "floor", floatLength.floor(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return (float) Math.floor(d);
                }
            });
            floatLength = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "rint", floatLength.rint(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return (float) Math.rint(d);
                }
            });
            floatLength = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "neg", floatLength.neg(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return -d;
                }
            });
            floatLength = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "times 3", floatLength.times(3f), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return 3 * d;
                }
            });
            floatLength = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "divide 7", floatLength.divide(7), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return d / 7;
                }
            });
        }
    }

    /**
     * Test the max and min methods.
     */
    @Test
    public void maxAndMinTest()
    {
        float lowest = -123.45f;
        float middle = -23.5f;
        float highest = 45.67f;

        FloatPosition lowestPosition = new FloatPosition(lowest, PositionUnit.FOOT);
        FloatPosition middlePosition = new FloatPosition(middle, PositionUnit.FOOT);
        FloatPosition highestPosition = new FloatPosition(highest, PositionUnit.FOOT);

        FloatPosition max = FloatPosition.max(lowestPosition, highestPosition);
        assertEquals(highestPosition, max, "max returns highest");
        // Reverse arguments
        max = FloatPosition.max(highestPosition, lowestPosition);
        assertEquals(highestPosition, max, "max returns highest");
        // Three arguments
        max = FloatPosition.max(lowestPosition, middlePosition, highestPosition);
        assertEquals(highestPosition, max, "max returns highest");
        max = FloatPosition.max(highestPosition, lowestPosition, middlePosition);
        assertEquals(highestPosition, max, "max returns highest");
        max = FloatPosition.max(lowestPosition, highestPosition, middlePosition);
        assertEquals(highestPosition, max, "max returns highest");
        // Lots of arguments
        max = FloatPosition.max(highestPosition, lowestPosition, highestPosition, middlePosition, middlePosition);
        assertEquals(highestPosition, max, "max returns highest");

        FloatPosition min = FloatPosition.min(lowestPosition, highestPosition);
        assertEquals(lowestPosition, min, "min returns lowest");
        // Reverse arguments
        min = FloatPosition.min(highestPosition, lowestPosition);
        assertEquals(lowestPosition, min, "min returns highest");
        // Three arguments
        min = FloatPosition.min(lowestPosition, middlePosition, highestPosition);
        assertEquals(lowestPosition, min, "min returns lowest");
        min = FloatPosition.min(highestPosition, lowestPosition, middlePosition);
        assertEquals(lowestPosition, min, "min returns lowest");
        min = FloatPosition.min(highestPosition, middlePosition, lowestPosition);
        assertEquals(lowestPosition, min, "min returns lowest");
        // Lots of arguments
        min = FloatPosition.min(highestPosition, lowestPosition, highestPosition, middlePosition, middlePosition);
        assertEquals(lowestPosition, min, "min returns lowest");
    }

    /**
     * Test that the toString method returns something sensible.
     */
    @Test
    public final void toStringRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.KELVIN;
        float value = 38.0f;
        FloatTemperature ds = new FloatTemperature(value, tempUnit);
        String result = ds.toString(true, true);
        assertTrue(result.contains("Rel "), "toString result contains \"Rel \"");
        assertTrue(result.contains("K"), "toString result contains \"K\"");
    }

    /**
     * Test constructor, verify the various fields in the constructed objects, test conversions to related units.
     */
    @Test
    public final void basicsRelTest()
    {
        TemperatureUnit tempUnit = TemperatureUnit.DEGREE_CELSIUS;
        float value = 38.0f;
        FloatTemperature temperatureDS = new FloatTemperature(value, tempUnit);
        checkContentsAndType(temperatureDS, value, 0.001f, tempUnit, false);
        assertEquals(38.0, temperatureDS.getSI(), 0.05, "Value in SI is equivalent in Kelvin");
        assertEquals(38.0 * 9.0 / 5.0, temperatureDS.getInUnit(TemperatureUnit.DEGREE_FAHRENHEIT), 0.1, "Value in Fahrenheit");
        float out = temperatureDS.getInUnit();
        assertEquals(value, out, 0.001, "Value should match");
        FloatTemperature mds = new FloatTemperature(value, tempUnit);
        checkContentsAndType(mds, value, 0.001f, tempUnit, false);
        FloatTemperature temperature2DS = new FloatTemperature(temperatureDS);
        assertTrue(temperature2DS.equals(temperatureDS), "temperature2DS should be equal to temperatureDS");
        assertTrue(temperatureDS.isRelative(), "Value is Relative");
        assertFalse(temperatureDS.isAbsolute(), "Value is not Absolute");
        temperatureDS = new FloatTemperature(value, TemperatureUnit.KELVIN);
        checkContentsAndType(temperatureDS, value, 0.001f, TemperatureUnit.KELVIN, false);
        out = temperatureDS.getSI();
        assertEquals(value, out, 0.001, "Value should match");
    }

    /**
     * Test the equals method.
     */
    @Test
    public final void equalsRelTest()
    {
        LengthUnit lengthUnit = LengthUnit.METER;
        PositionUnit positionUnit = PositionUnit.DEFAULT;
        float value = 38.0f;
        FloatLength ds = new FloatLength(value, lengthUnit);
        assertTrue(ds.equals(ds), "Equal to itself");
        assertFalse(ds.equals(null), "Not equal to null");
        assertFalse(ds.equals(new String("abc")), "Not equal to some other kind of object; e.g. a String");
        FloatPosition dsCounterPart = new FloatPosition(value, positionUnit);
        assertFalse(ds.equals(dsCounterPart), "Not equal if one Absolute and other Relative");
        FloatTemperature dsWrongBaseUnit = new FloatTemperature(value, TemperatureUnit.KELVIN);
        assertEquals(ds.getSI(), dsWrongBaseUnit.getSI(), 0.0001, "The underlying SI values are the same");
        assertFalse(ds.equals(dsWrongBaseUnit), "Not equals because the standard SI unit differs");
        FloatLength dsCompatibleUnit = new FloatLength(38000.0, LengthUnit.MILLIMETER);
        assertFalse(ds.getDisplayUnit().equals(dsCompatibleUnit.getDisplayUnit()), "Units are different");
        assertTrue(ds.equals(dsCompatibleUnit), "equals returns true");
        FloatLength dsDifferentValue = new FloatLength(123.456, LengthUnit.MILLIMETER);
        assertFalse(ds.equals(dsDifferentValue), "Different value makes equals return false");
    }

    /**
     * Test the relational operations.
     */
    @Test
    public final void relOpRelTest()
    {
        FloatLength base = new FloatLength(123, LengthUnit.KILOMETER);
        FloatLength same = new FloatLength(123000, LengthUnit.METER);
        FloatLength smaller = new FloatLength(122999, LengthUnit.METER);
        FloatLength larger = new FloatLength(123001, LengthUnit.METER);
        assertFalse(base.lt(same), "123km < 123000m");
        assertTrue(base.le(same), "123km <= 123000m");
        assertTrue(base.ge(same), "123km >= 123000m");
        assertFalse(base.gt(same), "NOT 123km > 123000m");
        assertTrue(base.eq(same), "123km == 123000m");
        assertFalse(base.ne(same), "NOT 123km != 123000m");
        assertTrue(base.lt(larger), "123km < 123001m");
        assertTrue(base.gt(smaller), "123km > 122999m");
        assertTrue(base.ge(same), "123km >= 123000m");
        assertFalse(base.gt(same), "NOT 123km > 123000m");
        assertFalse(base.lt(same), "NOT 123km < 123000m");
        assertTrue(base.le(same), "123km <= 123000m");
        assertTrue(base.ne(larger), "123km != 123001m");
        assertFalse(base.eq(larger), "NOT 123km == 123001m");
        assertTrue(base.ne(smaller), "123km != 122999m");
        assertFalse(base.eq(smaller), "NOT 123km == 122999m");
        assertFalse(base.ge(larger), "NOT 123km >= 123001m");
        assertFalse(base.le(smaller), "NOT 123km <= 122999m");
    }

    /**
     * Test the Math functions.
     */
    @Test
    public final void mathFunctionsTestRelTest()
    {
        float[] seedValues = {-10f, -2f, -1f, -0.5f, -0.1f, 0f, 0.1f, 0.5f, 1f, 2f, 10f};
        for (float seedValue : seedValues)
        {
            float input = seedValue;
            FloatLength ds;
            ds = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "abs", ds.abs(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return Math.abs(d);
                }
            });
            ds = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "ceil", ds.ceil(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return (float) Math.ceil(d);
                }
            });
            ds = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "floor", ds.floor(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return (float) Math.floor(d);
                }
            });
            ds = new FloatLength(input, LengthUnit.METER);
            MathTester.tester(input, "rint", ds.rint(), 0.001f, new FloatToFloat()
            {
                @Override
                public float function(final float d)
                {
                    return (float) Math.rint(d);
                }
            });
        }
    }

    /**
     * Test multiply(FloatScalarRel, FloatScalarRel).
     */
    @Test
    public final void binarymultiplyOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatLength left = new FloatLength(leftValue, LengthUnit.MILE);
        FloatLength right = new FloatLength(rightValue, LengthUnit.MILE);
        FloatSIScalar result = FloatScalar.multiply(left, right);
        assertEquals(left.getSI() * right.getSI(), result.getSI(), 0.001,
                "value of element should be SI multiply of contributing elements");
    }

    /**
     * Test divide(FloatScalarRel, FloatScalarRel).
     */
    @Test
    public final void binarydivideOfRelAndRelTest()
    {
        float leftValue = 123.4f;
        float rightValue = 234.5f;
        FloatLength left = new FloatLength(leftValue, LengthUnit.MILE);
        FloatLength right = new FloatLength(rightValue, LengthUnit.MILE);
        FloatSIScalar result = FloatScalar.divide(left, right);
        assertEquals(left.getSI() / right.getSI(), result.getSI(), 0.001,
                "value of element should be SI divide of contributing elements");
    }

    /** */
    interface FloatToFloat
    {
        /**
         * @param d value
         * @return float value
         */
        float function(float d);
    }

    /** */
    abstract static class MathTester
    {
        /**
         * Test a math function.
         * @param inputValue unprocessed value
         * @param operation description of method that is being tested
         * @param actualResult the actual result of the operation
         * @param precision expected accuracy
         * @param function encapsulated function that converts one inputValue to an outputValue
         */
        public static void tester(final float inputValue, final String operation, final FloatScalar<?, ?> actualResult,
                final float precision, final FloatToFloat function)
        {
            float expectedResult = function.function(inputValue);
            float got = actualResult.getSI();
            String description = String.format("%s(%f->%f should be equal to %f with precision %f", operation, inputValue,
                    expectedResult, got, precision);
            // System.out.println(description);
            assertEquals(expectedResult, got, precision, description);
        }

    }

}
